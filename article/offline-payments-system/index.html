<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="../../favicon.ico" />
    <link rel="stylesheet" href="../../style.css" />
    <title>jny0444</title>

    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";
    </script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <h3><a href="/index.html" class="back">← Go back</a></h3>
    <header>
      <h1><span class="sym">❯</span> Offline Payments System</h1>
    </header>

    <p>
      I tried creating an offline payments system in Rust inspired by Bitcoin's
      Lightning Network.
    </p>

    <ul>
      <li>
        <h3>
          <a href="#what-is-lightning-network">What is Lightning Network?</a>
        </h3>
      </li>
    </ul>

    <p>
      Lightning Network is a Bitcoin L2 where users can do off-chain
      transactions and later settle it on-chain.
    </p>
    <p>
      In this, two parties open a payment channel by locking funds in a
      multi-signature address. They transact off-chain by exchanging signed
      balance updates, broadcasting only the final state to the blockchain.
    </p>
    <p>
      This enables instant, low-cost transactions without waiting for on-chain
      confirmations.
    </p>

    <pre class="mermaid">
      sequenceDiagram
        participant On-chain Funding Tx
        participant Payment@{ "type" : "queue" }
        participant On-chain Closing Tx
        On-chain Funding Tx--&gt;Payment: Open Channel
        Payment--&gt;On-chain Closing Tx: Close Channel
    </pre>

    <p>
      You can read more about Lightning Network
      <a href="https://lightning.network/">here</a>.
    </p>

    <ul>
      <li>
        <h3><a href="#my-implementation">My Implementation</a></h3>
      </li>
    </ul>

    <p>
      I made something similar to how Lightning Network works in Rust. You can
      go through the repository
      <a href="https://github.com/jny0444/offline-pwa">here</a>. It still lacks
      a proper frontend, but you can try out the backend and the core contract
      logic.
    </p>
    <p>There are three main directories in the repo:</p>
    <ul>
      <li>
        <a
          href="https://github.com/jny0444/offline-pwa/tree/main/client"
          target="_blank"
          >Client</a
        >
      </li>
      <li>
        <a
          href="https://github.com/jny0444/offline-pwa/tree/main/contract"
          target="_blank"
          >Contract</a
        >
      </li>
      <li>
        <a
          href="https://github.com/jny0444/offline-pwa/tree/main/server"
          target="_blank"
          >Server</a
        >
      </li>
    </ul>

    <p>The core logic of the app lies in <code>contract</code> directory.</p>

    <ul>
      <li>
        <h3>
          <a href="#logic-impl">Logic Implementation of the Backend/Server</a>
        </h3>
      </li>
    </ul>

    <p>
      The main thing used in this is <code>alloy</code> crate. It helps you
      interact with blockchain in Rust.
    </p>
    <p>
      <code>/server/src/contracts</code> has all of the code required to
      interact with the smart contracts.
    </p>

    <p>
      When users register to the platform, a new custodial wallet is created and
      its private key is stored securely. Users need to first add some money as
      collateral for security, which wouldn't be shown as balance. Users can
      then add money to their balance.
    </p>

    <pre class="mermaid">
      sequenceDiagram
        participant User
        participant Server
        participant Blockchain
        User-&gt;&gt;Server: Register &amp; Deposit Collateral
        activate Server
        Server-&gt;&gt;Blockchain: Create Wallet &amp; Deposit Collateral Tx
        deactivate Server
        Server-&gt;&gt;User: Registration Successful
        User-&gt;&gt;Server: Add Funds to Balance
        activate Server
        Server-&gt;&gt;Blockchain: Deposit Funds Tx
        deactivate Server
        Server-&gt;&gt;User: Balance Updated
        User-&gt;&gt;Server: Initiate Payment to Another User
        activate Server
        Server-&gt;&gt;Blockchain: Create Payment Channel Tx
        deactivate Server
        Server-&gt;&gt;User: Payment Channel Established
        User-&gt;&gt;Server: Close Payment Channel
        activate Server
        Server-&gt;&gt;Blockchain: Settle Final Balance Tx
        deactivate Server
    </pre>

    <p>
      The users perform transactions by using the ERC-20 token
      <code class="token">$OFFPAY</code>. Users perform transactions off-chain
      and start a settlement period for 1 day or so. The payment has to be
      settle during that time by sending the final amount on-chain. If not, the
      amount will be slashed from their collateral.
    </p>

    <p>
      The main function responsible for settlement of payments is
      <code>call_settle_payment</code>.
    </p>
    <pre><code>use alloy::primitives::{Address, U256};
use chrono::{Duration, Utc};
use eyre::{Ok, Result};

use crate::{
    contracts::init::{init_contracts, init_provider_with_wallet},
    models::model::{Transaction, Wallet},
};

pub async fn call_settle_payment(
    transaction: &Transaction,
    wallet: &Wallet,
    to: Address,
    amount: U256,
) -> Result<()> {
    let (contract_address, provider) = init_provider_with_wallet(wallet).await?;

    let (contract, _) = init_contracts(&provider, contract_address).await?;

    let current_timestamp = U256::from(Utc::now().timestamp() as u64);

    let settle_time_period_in_seconds = U256::from(Duration::days(1).num_seconds() as u64);

    let elapsed_time = current_timestamp.saturating_sub(transaction.timestamp);

    if elapsed_time <= settle_time_period_in_seconds {
        let settle_payment_tx = contract.settlePayment(to, amount).send().await?;
        let _receipt = settle_payment_tx.get_receipt().await?;
    } else {
        let settle_payment_after_settlement_time_tx = contract
            .settlePaymentAfterSettlementPeriod(to, amount)
            .send()
            .await?;
        let _receipt = settle_payment_after_settlement_time_tx
            .get_receipt()
            .await?;
    }

    Ok(())
}</code></pre>

    <p>The type of object which this function will accept is of this format.</p>
    <pre><code>{
    "wallet": {
        "public_key": "0x8b4754842db66d1e31d166eb96cadb700dc2f3a4",
        "private_key": "0xe3dd13d6098228249925315caf3abca462a6edf1696b8d61b379906ff1353926"
    },
    "transaction": {
        "id": "1",
        "from": "0x8b4754842db66d1e31d166eb96cadb700dc2f3a4",
        "to": "0x1f41edf961bf379e0c10c9e5c94361b769806898",
        "amount": "100000000000000000",
        "timestamp": "1753807570",
        "is_settled": false,
        "tx_hash": "1f41edf961bf379e0c10c9e5c94361b769806898"
    },
    "amount": "100000000000000000"
}</code></pre>

    <p>
      You can read more about the models in <code>/server/src/models</code>,
      which contain information about how the data object format is defined.
    </p>

    <ul>
      <li>
        <h3>
          <a href="#contract-impl">Smart Contract Implementation</a>
        </h3>
      </li>
    </ul>

    <p>The contract implementation is rather simple compared to the backend.</p>

    <p>
      There are only 2 contracts which handle the payment channels and
      settlements.
    </p>

    <ul>
      <li>
        <a
          href="https://github.com/jny0444/offline-pwa/blob/main/contract/src/OffPay.sol"
          >OffPay.sol</a
        >
      </li>
      <li>
        <a
          href="https://github.com/jny0444/offline-pwa/blob/main/contract/src/OffPayToken.sol"
          >OffPayToken.sol</a
        >
      </li>
    </ul>

    <p>
      <code>OffPayToken.sol</code> is a simple ERC-20 token contract. The main
      logic is in <code>OffPay.sol</code>.
    </p>

    <pre><code>function settlePayment(address recipient, uint256 amount) external {
    User storage sender = users[msg.sender];
    User storage recip = users[recipient];
    require(sender.isRegistered, "Not registered");
    require(recip.isRegistered, "Recipient not registered");
    require(amount > 0, "Amount must be > 0");
    require(block.timestamp <= sender.last_txn_timestamp + SETTLEMENT_PERIOD, "Not within settlement period");
    require(sender.balance >= amount, "Insufficient balance");

    sender.balance -= amount;
    sender.last_txn_timestamp = block.timestamp;

    require(token.transfer(recipient, amount), "Token transfer failed");
    emit PaymentSettled(msg.sender, recipient, amount, false, block.timestamp);
}

function settlePaymentAfterSettlementPeriod(address recipient, uint256 amount) external {
    User storage sender = users[msg.sender];
    User storage recip = users[recipient];
    require(sender.isRegistered, "Not registered");
    require(recip.isRegistered, "Recipient not registered");
    require(amount > 0, "Amount must be > 0");
    require(block.timestamp > sender.last_txn_timestamp + SETTLEMENT_PERIOD, "Settlement period not yet over");
    require(sender.collateral - amount >= HEALTHY_COLLATERAL, "Collateral would fall below healthy threshold");
    sender.collateral -= amount;
    sender.last_txn_timestamp = block.timestamp;

    require(token.transfer(recipient, amount), "Token transfer failed");
    emit PaymentSettled(msg.sender, recipient, amount, true, block.timestamp);
}</code></pre>

    <p>
      The two functions <code>settlePayment</code> and
      <code>settlePaymentAfterSettlementPeriod</code> handle the settlement of
      payments within and after the settlement period respectively.
    </p>

    <ul>
      <li>
        <h3><a href="#conclusion">Conclusion</a></h3>
      </li>
    </ul>

    <p>
      This is the basic structure of the offline payments system using smart
      contracts and ERC-20 tokens.
    </p>

    <p>
      I have further plans of making this into a full-fledged protocol with a
      proper frontend, preferably a mobile app. There are many flaws in this
      approach I took, such as privacy and security, such as you cannot decide
      if the payment actually took place on-chain and many other such issues,
      which will be solved in a better and improved version of this in near
      future.
    </p>

    <footer>
      <div class="div-footer">
        <p>© <span id="year"></span> Jnyandeep Singh</p>
      </div>
    </footer>
    <script src="../../script.js"></script>
  </body>
</html>
